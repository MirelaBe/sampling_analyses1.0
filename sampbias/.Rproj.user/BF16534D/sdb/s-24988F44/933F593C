{
    "contents" : "SamplingBiasLarge <- function(x, outp.path = NULL, cellsize = 2, \n                              verb = T, ...) {\n  \n  if(dim(x)[1] < 10000){\n    out <- SamplingBias(x, ...)\n  }else{\n  \n  intpref <- x\n  \n  if (min(x[, 1]) * max(x[, 1]) < 0) {\n    lonspan <- abs(min(x[, 1])) + abs(max(x[, 1]))\n  } else {\n    lonspan <- abs(abs(max(x[, 1])) - abs(min(x[, 1])))\n  }\n  if (min(x[, 2]) * max(x[, 2]) < 0) {\n    latspan <- abs(min(x[, 2])) + abs(max(x[, 2]))\n  } else {\n    latspan <- abs(abs(max(x[, 2])) - abs(min(x[, 2])))\n  }\n  \n  ras <- coordinates(raster(nrows = ceiling(lonspan/(cellsize * 2)), \n                            ncols = ceiling(latspan/(cellsize * 2)), \n                            xmn = min(x[, 1]), xmx = max(x[, 1]),\n                            ymn = min(x[, 2]), ymx = max(x[, 2])))\n  ras <- ras <- GridTopology(cellcentre.offset = c(min(x[, 1]), min(x[, 2])), \n                             cellsize = c((cellsize * 2), (cellsize * 2)), \n                             cells.dim = c(ceiling(lonspan/(cellsize * 2)),\n                                           ceiling(latspan/(cellsize * 2))))\n  ras <- coordinates(ras)\n  \n  cr <- list()\n  for (i in 1:dim(ras)[1]) {\n    cr[[i]] <- extent(c(ras[i, 1] - (cellsize - 1e-08), ras[i, 1] + \n                          cellsize, ras[i, 2] - (cellsize - 1e-08), ras[i, 2] + cellsize))\n  }\n  \n  dat2 <- SpatialPoints(x)\n  rownames(dat2@coords) <- rownames(x)\n  dat <- lapply(cr, function(x) crop(dat2, x))\n  dat <- dat[!unlist(lapply(dat, is.null))]\n  dat <- lapply(dat, coordinates)\n  mis <- as.numeric(unlist(lapply(dat, rownames)))\n  mis <- x[which(!rownames(x) %in% mis), ]  # add entries missed by geographic splitting\n  dat[[length(dat) + 1]] <- mis\n  dat <- lapply(dat, function(z) {\n    splitter <- rep(1:ceiling(dim(z)[1]/10000), each = 10000)\n    splitter <- splitter[1:dim(z)[1]]\n    splitter <- split(data.frame(z), f = splitter)\n    return(splitter)\n  })\n  dat <- list(unlist(dat, recursive = F))[[1]]\n  \n  if (is.null(outp.path)) {\n    li <- lapply(dat, function(z) SamplingBias(z, refinterpoint = intpref, ...))\n    out <- do.call(\"rbind.data.frame\", li)\n    tt <- as.numeric(unlist(lapply(li, \"rownames\")))\n    out <- out[order(tt), ]\n    rownames(out) <- rownames(x)\n    \n  } else {\n    tt <- SamplingBias(dat[[1]], refinterpoint = intpref, verbose = F, ...)\n    rownames(tt) <- rownames(dat[[1]])\n    write.table(tt, outp.path, sep = \"\\t\")\n    for (i in 2:length(dat)) {\n      if (verb == T) {\n        print(paste(i, \"/\", length(dat)))\n      }\n      tt <- SamplingBias(dat[[i]], refinterpoint = intpref, verbose = F, ...)\n      rownames(tt) <- rownames(dat[[i]])\n      write.table(tt, outp.path, append = T, col.names = F, sep = \"\\t\")\n      rm(tt)\n    }\n    out <- read.table(outp.path, sep = \"\\t\", row.names = NULL)\n\n    cor <- x[which(!rownames(x) %in% out$row.names),]\n    if( dim(cor)[1] > 0){\n      if(verb == TRUE){\n        cat(\"Applying corrections\") # sometimes samples are missed so that dim(out) != dim(x), so here check for this\n      }\n    if(dim(cor)[1] > 10000){\n    cor <- lapply(cor, function(z) {\n      splitter <- rep(1:ceiling(dim(z)[1]/10000), each = 10000)\n      splitter <- splitter[1:dim(z)[1]]\n      splitter <- split(data.frame(z), f = splitter)})\n      return(splitter)\n      for (i in 2:length(cor)) {\n        if (verb == T) {\n          print(paste(i, \"/\", length(cor)))\n        }\n        tt <- SamplingBias(dat[[i]], refinterpoint = intpref, verbose = F, ...)\n        rownames(tt) <- rownames(dat[[i]])\n        write.table(tt, outp.path,  append = T, col.names = F, sep = \"\\t\")\n        rm(tt)\n      }\n    }else{\n      tt <- SamplingBias(cor, refinterpoint = intpref, verbose = F, ...)\n      rownames(tt) <- rownames(cor)\n      write.table(tt, outp.path, append = T, col.names = F, sep = \"\\t\")\n      rm(tt)\n    }\n    }\n    out <- read.table(outp.path, sep = \"\\t\", row.names = NULL)\n    \n    out <- out[!duplicated(out$row.names),]\n    rownames(out) <- out$row.names\n    out <- out[, -1]\n    out <- out[order(as.numeric(rownames(out))), ]\n  }\n  }\n  return(out)\n} ",
    "created" : 1448489356698.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2991937361",
    "id" : "933F593C",
    "lastKnownWriteTime" : 1441373804,
    "path" : "C:/Users/xzizal/Desktop/GitHub/sampbias/R/SamplingBiasLarge.R",
    "project_path" : "R/SamplingBiasLarge.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}